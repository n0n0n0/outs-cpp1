# CMake

Создаем в папке с проектом файл CMakeLists.txt	(vscode - Ctrl + Alt + P -> type "CMake: QuickStart" - визард простой по настройке проекта под CMake
`cmake -B build`	- собираем проект в папку build (точно что делает на этом этапе пока не известно
`cmake --build build` 	- собираем исполняемый файл (из объектных файлов собранных ранее?)

## Главные команды CMake

1. `cmake_minimum_required(VERSION 3.5)` - лучше писать первой строкой, определяет минимальную версию
CMake установленную в системе для обработки нашего файла
2. `project(<название проекта> VERSION 0.1.0 LANGUAGES C CXX)` - название проекта
3. CMake работает с "таргетами" и это может быть либо исполняемый файл (executable) либо библиотека.
   Между таргетами могут быть установлены зависимости (исполняемый файл зависит какой-то библиотеки)

Создать exe-шник из проекта:
```
add_executable(
	my_app				// название экзешника
	file.cpp			// из чего собираем
	file2.cpp 
	...
)
```
Добавляем опции компилирования для каждого таргета. Например указываем что таргет my_app должен 
собираться компилятором, который должен поддерживать стандарт **cxx_std_17**
И дополнительная опция требует указание стандарта в проекте (CXX_STANDART_REQUIRED ON)
```
target_compile_features(my_app PUBLIC cxx_std_17)
set_target_properties(my_app PROPERTIES CXX_STANDART_REQUIRED ON)
```

CMake позволяет определять вспомогательные (кастомные) "таргеты". Например ниже таргет копирования некого возможного конфиг-файла в директорию с бинарником при сборке. Где CMAKE_COMMAND это собсно исполняемый файл cmake в ОС (с путем или пути через PATH найдет). Чтобы кастомный таргет выполнился в ходе обработки основного таргета нужно прописать зависимость через `add_dependencies`
```
add_custom_target(copyConfig
	COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/some_config.json ${CMAKE_BINARY_DIR}/config.json 
)
add_dependencies(my_app copyConfig)
```

Можно сгенерировать файлы под разные системы сборки (где-то по умолчанию будет make, на винде msbuid или vsbuild как-то так). Чтобы сгенерировать файлы под другую систему сборки из нашего CMake проекта можно сделать так в консоли (т.е. ключ -G и указываем название системы сборки):
> cd build_ninja

> make .. -G "Ninja"

### Работа с переменными
"set" is set, ${} is get
```
set(PATCH_VERSION "1" CACHE INTERNAL "")
set(PROJECT_VERSION 1.0.${PATCH_VERSION})
set(SOURCES			// типа массив
	f1.cpp
	f2.cpp
)
...
project(my_proj VERSION ${PROJECT_VERSION})
...
add_executable(my_app ${SOURCES} ${HEADERS})
```
Можно задать значение переменной извне, из консоли вызова cmake:
`> cmake .. -DPATCH_VERSION=112`
Такой подход удобен тем, что версию можно формировать при CI/CD и брать номер билда из "сборочного конвейра" и тогда её легко подставлять в момент сборки как переменную в консольную команду cmake.
Подменять код внутри h/cpp файлов можно при помощи директивы `#cmakedefine ...`

### Компиляция без CMake
> g++ -c main.cpp			-> получаем main.o объектный файл

> g++ main.o -o hello		-> получаем ехе-файл в директории с названием hello.exe

Можно добавлять в проект подпроекты (поддиректории) в которых тоже должен быть файл CMakeLists.txt
add_subdirectory(static_library)	где static_library - название папки в папке проекта

[CMake статические и динамические библиотеки](cmake-library.md)
[CMake установка библиотеки в систему](cmake-library-install.md)
[CMake использование библиотеки через find_package(name MODULE ...)](cmake-library-module.md)

## Статические библиотеки
> набор объектных файлов (.o, .obj) в архиве (натурально, можно распаковать 7-zip) с заголовочными файлами", 
> в винде (а может и линухе?) с расширением .lib
> кодовая база статичной библиотеки зашивается прям в exe-файл

В CMake проект со статической библиотекой:
project(04.linkage)

```
add_library(
	datetime	<- название библиотеки (выходного файла)

	STATIC		<- тип библиотеки (может быть STATIC и SHARED)

	datetime.cpp
	datetime.h
	# ... 
)
```

## Динамические библиотеки
> набор объектных файлов (.o, .obj) скомпилированные и слинкованные в по сути исполняемый файл без функции main
> в винде - .dll (dynamic load library) в линуксе - .so (shared objects)
> такие файлы не зашиваются в exe, а идут отдельными файлами подключаются в runtime (после запуска программы)
> также нужны заголовочные файлы для работы с ней

В CMake проект с динамической библиотекой:
project(04.linkage)

```
add_library(
	datetime	<- название библиотеки (выходного файла)

	SHARED		<- тип библиотеки (может быть STATIC и SHARED)

	datetime.cpp
	datetime.h
	# ... 
)
```

## Подключение библиотек в проект CMake:
```
target_link_library {
	test_app_datetime		# название таргета = екзешника, который указан в проекте как add_executable
	PRIVATE					# тип линковки, можно PUBLIC тогда другие библиотеки будут знать эту
	datetime				# название библиотеки Cmake узнает об этом через add_subdirectory(папка со статичной либой) 
							# там в CMakeLists add_library(<первый параметр - название библиотеки>, ...)
}
```
