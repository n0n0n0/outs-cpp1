# Move constructor (move semantic), noexcept
Для примера возьмем класс
```cpp
Complex {
public:
    Complex(){}
    explicit Complex(float f) : m_real{f}, m_im{0} {}
    Complex(float r, float im) : m_real{r}, m_im{im} {}
    ~Complex() {}
    Complex operator+(const Complex &) { ... }
private:
    float m_real;
    float m_im;
    char *m_data;
}
```
Для семантики перемещения нужно знать следующее:

## Временные (неименованные) объекты
Могут порождаться в следующих случаях:
1. Возврат из функции:
```cpp
Complex calc() {
    Complex c1{5};
    return c1;
}

int main() {
    Complex c2 = calc(); // здесь calc() вернет временный объект
}
```
2. Инициализация
```cpp
Complex c1{Complex{c2}}; // Complex{c2} - возвратит временный объект
```
3. Вычисление объектов
```cpp
Complex c1{3}, c2{2, 3};
Complex c3 = c1 + c2; // (c1 + c2) сгенерирует и вернет временный объект
```
4. Явно пометить объект как временный
```cpp
Complex c1{1};
Complex c2{std::move(c1)}; // std::move делает c1 объект "временным"
Complex c3 = std::move(c1); // также делаем с1 временный
```

## Конструктор перемещения, перемещающий оператор присваивания
Конструктор перемещения похож на конструктор копирования, но на вход принимает **временный** объект  
помеченный как && (&& - это и есть отличительная черта временного объекта):
```cpp
// обычный копирующий конструктор, когда справа приходит не временный объект
Complex(Complex &rhs) {} 
// перемещающий конструктор, попадем сюда только если справа временный объект
Complex(Complex &&rhs) 
    : m_data(nullptr), m_real{0}, m_im{0}
{ 
    // во временный объект в rhs.m_data уйдет nullptr, чтобы при деструкторе и delete m_data
    // во временном объекте не удалилась "сворованная" область памяти m_data
    std::swap(rhs.m_data);  
    std::swap(rhs.m_real);  // тут также уйдут нули инициализированные вначале конструктора этого
    std::swap(rhs.m_im);
}
```
Похожим образом можно определить перемещающий конструктор присваивания
```cpp
// обычный оператор присваивания
Complex& operator=(const Complex &rhs) {
    // copy logic here
    return *this;
}

// перемещающий оператор присваивания, попадем сюда только если справа временный объект
Complex& operator=(const Complex &&rhs) {
    // в отличие от конструктора не забываем тут сначала удалить текущие ресурсы
    delete m_data;
    m_data = nullptr;

    // дальше также как в перемещающем конструкторе
    std::swap(rhs.m_data);  
    std::swap(rhs.m_real);
    std::swap(rhs.m_im);
}
```

## Поведение в контейнерах stl, noexcept
Если мы будем использовать наш объект в контейнерах stl то можем столкнуться с такой ситуацией,  
что например каждый раз при добавлении в вектор элемента нашего типа будет много раз вызываться  
конструктор копирования для уже лежащих в нем элементов при переаллокации памяти. Но stl контейнеры  
могут поступать умнее, и если у move ctor будет модификатор noexcept, означающий, что этот метод  
точно не выбрасывает исключение (и таким образом это безопасная операция с точки зрения искажения  
данных в процессе перемещения) то будет использоваться перемещающий консткрутор вместо копирующего,  
а это гораздо быстрее
```cpp
Complex& operator=(const Complex &&rhs) noexcept {}
```

## implicit deleted copy ctor
В [cppreference](https://en.cppreference.com/w/cpp/language/copy_constructor), описаны случаи, когда copy constructor неявно (implicit) удален, и тогда могут быть ошибки при использовании нашего класса в контейнерах (например в Qt QMap<QString, Complex>). Это может быть в частности если для класса объявлен **move constructor** или **move assignment operator** и тогда copy ctor будет неявно удаленв в этом классе. Так что определяя конструктор перемещения в своём классе, нужно позаботиться и об объявлении конструктора копирования и оператора копирующего присваивания

## Случаи использования
1. Инициализация временного объекта, а потом помещение его в контейнер
```cpp
Complex c1;
c1.setData(...);
c1.setReal(...);
std::vector<Complex> v1;
v1.emplace_back(c1); // copy
v1.emplace_back(std::move(c1)); // move, faster
```
2. Перемещение из контейнера в контейнер (2 очереди задач, например)
```cpp
std::vector<Complex> v1 = {...}, v2 = {...};
Complex temp = std::move(v1.back()); // move ctor
v1.pop_back();
v2.emplace_back(std::move(temp)); // move ctor
```
3. Перемещение внутри контейнера

## Universal references
Универсальная ссылка это ситуация только с шаблонной функцией вида
```cpp
template<typename T>
void func(T&& x) {  
    // T&& - и есть унивесальная ссылка, эта функция будет использоваться и для
    // T и для T& (lvalue) и для T&& (rvalue)
    ...
    // передать в другую функцию в неизменном (относительно lvalue/rvalue) виде
    // можно так:
    func2(std::forward<T>(x));
}
```