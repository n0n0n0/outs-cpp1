# CPP Features

## Explicit constructor
Ситуация когда у функции параметры объекты с конструктором где один int параметр, а в функцию  передаются 2 int переменные, например:
```cpp
class Distance {
    Distance(int v) ...     // разрешает неявное преобразование int -> Distance(int)
    explicit Distance(float f) ... // запретит неявное преобразование float -> Distance(float)
};

class Weight {
    Weight(int v) ...
};

int get_delivery_price(Distance d, Weight w) { ... }
...
int weight = 5, distance = 7;
// параметры логически перепутаны местами, такую ошибку найти будет сложно
// логика может работать не правильно, но никаких ошибок в программе может не быть
get_delivery_price(weight, distance);   
```
Т.е. тут в момент вызова get_delivery_price(a, b) неявно вызовутся конструкторы Distance(int) и Weight(int). Ключевое слово `explicit` перед объявлением конструктора запретит неявное обращение к конструтору в случае, как в примере, передачи параметров через функцию, или, например:
```cpp
Distance d = 5;     // тут тоже неявно вызовется конструктор Distance(int)
```
> Рекомендуется делать все конструкторы explicit у которых один аргумент или другие кроме одного аргумента заданя с параметрами по умолчанию!

## Переопределение оператора преобразования к типу
Во-первых оно может быть неявное, но теперь в обратну сторону из класса в простой тип и выглядит внутри класса так:
```cpp
class Error {
operator bool() const { return m_isError; }
...
}
...
main() {
    Error error;
    // поскольку оператор if требует bool то произойдет неявное преобразование
    // из объекта error в bool т.к. объявлен соответствующий оператор для класса
    if(error) {
        // do smth
    }
}
```
Причем такой оператор тоже можно объявить как explicit:
```cpp
class Error {
explicit operator bool() const { return m_isError; }
...
```
И тогда его нельзя будет неявно вызывать как в `if(error)`.  
Но можно будет вызвать явно как `bool isError = static_cast<bool>(error);`

## operator+= operator+ operator-
Синтаксис такой:
```cpp
// 1. внутри класса
class Complex {
    // rhs - right hand side
    // lhs - left hand side
    Complex& operator+=(Complex rhs) {
        // ...
    }
};

// 2. как свободная функци
Complex& operator+=(Complex c1, Complex c2) {
    // ...
}
// или так
Complex& operator+=(Complex c1, float c2) {
    // ...
}
```
> Лучше всегда использовать свободные функции когда возможно, меньше нагружает класс. Но если сильно удобней в классе то можно в классе

## Копирующий конструктор
Синтаксис такой:
```cpp
class Complex {
    Complex(const Complex &other) m_real{other.real}, m_im{other.im} {}

    // так нельзя т.к. чтобы вызвать в параметр надо скопировать объект
    // а чтобы скопировать объект нужно вызывать этот конструктор копирования :)
    // получится рекурсия. Не скомпилируется
    //Complex(Complex other) m_real{other.real}, m_im{other.im} {}

    Complex& operator=(const Complex &other) {
        m_real = other.real
        m_im = other.im;
        return *this;
    }
    ...
}

// Где же вызовется конструктор копирования?
void func(Complex copy) {}

Complex c{1,2};
// тут не буде создан "временный" объект Complex{3,4} для присваивания, вместо этого компилятор
// вызовет сразу конструктор копирования
Complex not_a_copy = Complex{3,4}; 

Complex copy = c;   // это не присваивание а копирующий конструктор т.к. объявление переменной
Complex copy2{c};

func(c);            // тоже конструктор копирования

Complex assing;
assign = c;         // тут вызов operator= т.к. объект уже существует

Complex assign2;
assign2 = assign = c;
```

## method() = delete; Что это?
По скольку компилятор сам генерирует конструкторы копирования и operator= но нам может понадобиться запретить копирование и присваивание объекта (например объект представляет собой файл и что делать при копировании? скопировать файл? с таким же именем?). Тогда мы можем помечать такие конструкторы как ` = delete` и компилятор не сгенерирует такие конструкторы и объект будет запрещен к копированию (и если надо присваиванию).
```cpp
class Complex {
    Complex(const Complex &other) = delete;
    Complex& operator=(const Complex &other) = delete;
}
```

## Move assignment & move ctor (Оператор перемещения)
Во-первых нам понадобится "временный объект" - `DynamicString(DynamicString&& other)` - это знак **&&** обозначает "временный объект". Самый простой пример временного объекта - тот который возвращается функцией через значение. Внутри функции он создается, потом возвращается во вне, и потом удаляется. И если такой объект будет параметром функции то мы об этом узнаем если сделаем функцию с одним параметром с && (двойным амперсантом) и вызваться эта функция сможет только в случае если единственный её параметр-объект будет именно временным объектом.
```cpp
DynamicString {
    // копирующий конструктор вызовется для не временного объекта, компилятор гарантирует
    DynamicString(const DynamicString &other) {}  

    // конструктор перемещения вызовется только для "временного объекта"
    DynamicString(DynamicString &&other) {}
    // Оператор присваивания тоже можно сделать отдельно для временного объекта
    DynamicString operator=(DynamicString &&rhs) {}
}

DynamicString test(char * str) { return DynamicString(str); }
...
// тут как раз вызовется конструктор перемещения, т.к. возвращаемый 
// из функции объект - временный
DynamicString ds = test("Hello"); 
DynamicString ds3{DynamicString{"Hello"}}; // тоже move ctor

// есть магический std::move() который делает любой нормальный объект временным, т.е.
// тут вызовется тоже move ctor т.к. std::move вренула просто ds' который копия ds только временная
DynamicString ds4(std::move(ds)); 

DynamicString ds2 = ds; // тут копирующий конструктор
```