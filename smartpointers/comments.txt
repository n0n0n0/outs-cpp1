Целью было проверить, когда удаляются (когда срабатывают деструкторы) умные указатели которые
являются членами других классов.
Поскольку они сами не указатели - то естественно удаляются когда удаляется сам класс, в котором
они находятся (например при выходе за scope {} или выход из функции где класс-владелец был создан)
Но что будет если класс-владелец сам будет указателем?
Тогда он удалится либо руками через delete либо также если он будет обернут в умный указатель
то тоже delete вызовется.
Выяснились нюансы:
1. В своей реализации если хотим сделать умный указатель членом класса какого-нибудь
то нужно делать конструктор "по умолчанию" (без параметров), т.к. когда объявляем член
класса внутри мы не присваиваем ему еще значение, оно будет потом проинициализировано
скорее всего в конструкторе. Или можем всётаки сделать = nullptr это будет инициализация
и для этого нужен только консткрутор с одним параметром-указателем.
2. В умном указателе должен быть определен конструетор копирования и оператор присваивания. 
Для uniq парадигмы это должны быть конструктор перемещения && и оператор присваивания 
временного объекта (тоже &&).
3. В Qt или std для реальной инициализации QScopedPointer (или std::unique_pointer) в конструкторе
есть метод reset(T *other (= nullptr для QScopedPointer))